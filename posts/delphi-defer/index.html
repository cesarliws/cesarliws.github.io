<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Cesar Romero">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.19" />

    
    <title>Delphi Defer &middot; @cesarliws’s cooking bytes</title>

    <link rel="stylesheet" href="https://cesarliws.github.io/css/weblog.css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.2.14/css/lightgallery.min.css" type="text/css" />
    <link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />


    
	<link href="https://cesarliws.github.io/index.xml" rel="alternate" type="application/rss+xml" title="cooking bytes" />
	
  </head>
  <body class="site">

<header>
  <nav>
    <h1><a href="/">@cesarliws</a>’s cooking bytes.</h1>
    <div class="menu">
      
      <ul>
        
            <li>
              <a href="/">Home</a>
              
                <a href="/index.xml"><img src="/img/rss.svg" class="rss-icon" /></a>
              
            </li>
        
            <li>
              <a href="/posts/">Posts</a>
              
                <a href="/posts/index.xml"><img src="/img/rss.svg" class="rss-icon" /></a>
              
            </li>
        
        
      </ul>
    </div>
  </nav>
</header>


  <main class="content">

    <article class="post">
      
        <h2><a rel="full-article" href="https://cesarliws.github.io/posts/delphi-defer/">Delphi Defer</a></h2>
      

      <div class="postmeta">Posted on <time datetime="2017-04-05 17:02:27 -0300 BRT" pubdate="">April 5, 2017</time> in
        <span class="categories">
          
        </span>
      </div>

      <p>
        

<h2 id="origem">Origem</h2>

<p>Na semana passada eu estava refatorando um código do framework &ldquo;Foundation 4 Delphi&rdquo;, pois precisava extender o TComponent.TRecursiveEnumerator para utilizar em outras classes, era uma implementação antiga e resolvi reescrever com generics e aproveitar a vantagem dos smart records para simplificar a integração com o meu TComponentHelper class helper.</p>

<p>Na implementação do record, precisei criar um field &ldquo;IInterface&rdquo; apenas para poder simular um destructor no record, foi quando eu pensei como seria bom se tivessemos o <a href="https://golang.org/doc/effective_go.html#defer" target="_blank">Defer</a> do Golang. Quando estava escrevendo os testes unitários, novamente senti a necessidade do Defer, foi quando decidi pensar mais no padrão e comportamento do Defer, o que me levou a tentar implementar em Delphi, apenas para um exercício de lógica, mesmo inicialmente achando que não seria algo útil para produção, mas para a minha surpresa, consegui algo muito útil.</p>

<h2 id="o-conceito">O Conceito</h2>

<p><img src="/img/postponed.jpg" alt="Postpone image" />
Defer define o padrão &ldquo;adiar a execução de uma procedure&rdquo;, este adiamento deve agendar a execução de uma &ldquo;procedure TProc&rdquo; para após o fim do método que executou a chamada ao Defer(Procedure: TProc).</p>

<p>No final do método o Defer deve executar todas as procedures empilhadas na ordem inversa ao agendamento.</p>

<p><a href="https://golang.org/doc/effective_go.html#defer" target="_blank">Defer de acordo com a documentação da Golang</a>:</p>

<blockquote>
<p>A declaração defer agenda a chamada da função (a função adiada) para ser executada imediatamente antes da função executando o defer retornar. É uma maneira incomum, mas eficiente de lidar com situações em que recursos devem ser liberados independentes do fluxo que a função executar até retornar. Os exemplos regulares são desbloquear um mutex ou fechar um arquivo.</p>
</blockquote>

<p>Uma informação importante aqui, é que Golang é uma linguagem com garbage collection, então não é necessário destruir os objetos criados, apenas desalocar recursos.</p>

<p>E independente do fluxo executado na função o Defer sempre deve executar os métodos já agendados, então se houver um Exit antes do final ou se ocorrer uma exceção, todos os métodos agendados devem ser executados.</p>

<p>Nas minhas pesquisas, descobri que o Defer foi implementado para Swift da Apple, na versão 2.0. Gostei do título deste artigo, try/finally feito corretamente.:</p>

<ul>
<li><a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer" target="_blank">The defer keyword in Swift 2: try/finally done right</a></li>
</ul>

<p>Também li em uma discussão no reddit que este recurso existe na linguagem D, mas não encontrei referências.</p>

<h3 id="outros-utilidades-para-o-defer">Outros utilidades para o Defer</h3>

<ul>
<li>Fechar conexão, transação ou query</li>
<li>Finalizar conexão de socket</li>
<li>Fechar arquivos abertos</li>
<li>Desbloquear critical section</li>
</ul>

<h2 id="a-implementação">A Implementação</h2>

<p>Após analisar o comportamento e entender como o Defer dever funcionar, comecei a implementar utilizando Interfaces, assim ela seria automaticamente desalocada quando a Interface sair de contexto, esta foi fácil.
<pre>
  IDeferrer = Interface(IInterface)
    function Defer(Proc: TProc): IDeferrer;
  end;
</pre>
Seguindo o padrão adotado em Golang para nomear Interface, adicionei o sufixo &ldquo;er&rdquo; e fiz o ajuste para ficar de acordo gramaticalmente.</p>

<p>Internamente, ele deve manter uma pilha com a lista de TProc agendadas, assim estes métodos podem ser executados em ordem inversa quando o objeto TDefer for destruído, sem problemas pois Delphi tem uma implementação de TStack&lt;T&gt; em System.Generics.Collections, mas aqui teve um truque, pois na hora de tirar o TProc da pilha, estava tendo alguns problemas que resolvi decorando o TProc com um record TStackItem antes de armazenar.</p>

<pre class='brush: delphi'>
type
  TDeferrer = class(TInterfacedObject, IDeferrer)
  strict private
    type
      TStackItem = record
        Proc: TProc;
      end;
  strict private
    FStack: TStack\<TStackItem\>;
    procedure Push(Proc: TProc);
    procedure ProcessStack;
  public
    constructor Create; overload;
    constructor Create(Proc: TProc); overload;
    destructor Destroy; override;
    function Defer(Proc: TProc): IDeferrer;
  end;
</pre>

<p>E para finalizar, criei uma função global que retorna o IDeferrer:
<pre>
function Defer(Proc: TProc): IDeferrer;
begin
  Result := TDeferrer.Create(Proc);
end;
</pre></p>

<h2 id="como-usar">Como usar</h2>

<p>O objetivo do Defer é adiar métodos, não gerenciar o tempo de vida de objetos, mas como em Delphi Win32/Win64 os objetos são gerenciados manualmente, podemos utilizar o Defer para destruir os objetos, além de finalizar outros recursos.
<pre>
uses
  Foundation.System;
var
  Database: TDatabase;
  Exec: IDeferrer;
  Query: TQuery;
  Transaction: TTransaction;
begin
  Database := TDatabase.Create(FWriter);
  Exec := Defer(Database.Free);
  Database.Open(&lsquo;foundation-db&rsquo;);
  Exec.Defer(Database.Close);
  Transaction := Database.StartTransaction;
  Exec.Defer(Transaction.Free);
  Exec.Defer(Transaction.Commit);
  Query := Transaction.Query;
  Exec.Defer(Query.Free);
  if Query.Open(&lsquo;select value from table&rsquo;) then
  begin
    Exec.Defer(Query.Close);
  end;
end;
</pre></p>

<p>Este código é parte dos testes unitários que eu escrevi, os objetos são apenas Mock e o FWriter passado no construtor é utilizar para gravar as etapas, para que eu possa testar o resultado, aqui está o resultado do log do defer neste método:
<pre>
  TDatabase.Open = foundation-db
  TDatabase.StartTransaction
  TTransaction.Query
  TQuery.Create
  TQuery.Open(select value from table) = True
// Defer inicia aqui
  TQuery.Close
  TQuery.Free
  TTransaction.Commit
  TTransaction.Free
  TDatabase.Close
  TDatabase.Free
</pre></p>

<p>Note que o Defer acontece apenas depois de TQuery.Open, exatamente na ordem inversa em que os métodos foram agendados no Defer.</p>

<p>Outro detalhe é a declaração da variável &ldquo;Exec: IDeferrer&rdquo; para reutilizar a mesma instância. Declarando uma variável e reutilizando nas próximas chamadas somente uma instância é alocada, algo que pode ser dispensado para o benefício de ter o código mais limpo com uma pequena sobrecarga.</p>

<p>Se a referência do IDeferrer não for armazenada em uma variável local, uma nova instância será criada a cada chamada ao Defer. Seria um problema se a ordem em que as instâncias são desalocadas não fosse a mesma do Defer, mas o comportamento foi consistente em todos os testes. Acredito ser o comportamento padrão do gerenciador de memória do Delphi, o FastMM, armazenar as instâncias alocadas em uma pilha, desta forma a ordem para desalocar é a mesma da implementação do Defer. Se o gerenciador de memória do seu projeto for outro como ScaleMM ou Nexus Memory Manager sugiro fazer testes antes de usar o Defer.</p>

<h3 id="uma-implementação-alternativa">Uma implementação alternativa</h3>

<p>Na pasta Experimental do repositório tem uma implementação alternativa que extende o Defer na unit <a href="https://github.com/cesarliws/foundation-4-delphi/blob/master/Experimental/Foundation.Pattern.Defer.Auto.pas" target="_blank">Foundation.Pattern.Defer.Auto.pas</a>.</p>

<p>Esta implementação captura a Thread e o ponteiro do método que chamou o Defer e as utiliza como chave para salvar a instância do Defer em um TDictionary&lt;string, IDeferrer&gt; para reutilizar sempre a mesma instância. Funcionou em todos os testes executados em win32, win64, single e multi thread.</p>

<p>Para capturar o ponteiro do método que iniciou a chamada utilizei a unit <a href="https://github.com/project-jedi/jcl/blob/master/jcl/source/windows/JclDebug.pas" target="_blank">JclDebug.pas</a> do projeto Jedi Jcl. Para win32 foi possível extrair o básico necessário e colocar na unit <a href="https://github.com/cesarliws/foundation-4-delphi/blob/master/Experimental/Foundation.Vendor.JclDebug.pas" target="_blank">Foundation.Vendor.JclDebug.pas</a>, com os devidos créditos e licença, dispensando a necessidade de instalar a Jcl completa no ambiente de testes. Para win64 é necessário utilizar a unit JclDebug, também recomendada para ambiente de produção.</p>

<p>A vantagem é clara, apenas uma instância de Defer é criada para cada método de origem, mas por outro lado a sobrecarga gerada da implementação da lista em TDictionary, o mutex necessário para garantir o bom comportamento em multi thread e a dependência da Jcl são maiores do que declarar uma variável ou ter mais de uma instância por método de origem. Tendo em mente que em um comportamento padrão de uma aplicação normal, não haverá muitas instâncias ao mesmo tempo.</p>

<h3 id="mais-exemplos">Mais exemplos</h3>

<h4 id="métodos-anônimos">Métodos Anônimos</h4>

<pre>
  Database := TDatabase.Create(FWriter);
  Database.Open('database-name');
  Defer(
    procedure
    begin
      Database.Close;
      Database.Free;
    end
  );
</pre> 

<h4 id="também-consegui-implementar-um-tracer">Também consegui implementar um Tracer</h4>

<pre>
class function TTrace.Method(Writer: TStringsWriter; const MethodName: string; var TraceProc: ITracer): IDeferrer;
var
  {! Workaround "Defer(ITracer.Exit)" : E2010 Incompatible types: 'TProc' and 'procedure, untyped pointer or untyped parameter' }
  Trace: TTrace;
begin
  Trace := TTrace.Create(Writer);
  Trace.Enter(MethodName);
  Result := Defer(Trace.Exit);
  Supports(Trace, ITracer, TraceProc)
end;

var
  Trace: ITracer;
begin
  TTrace.Method(FWriter, 'DelegateDeferToTraceExecute', Trace);
  Trace.Step('First');
  Trace.Step('Second');
  Trace.Step('Third');
end;
</pre> 
Que gerou o log: 
<pre>
    > Enter DelegateDeferToTraceExecute
        1. DelegateDeferToTraceExecute: First
        2. DelegateDeferToTraceExecute: Second
        3. DelegateDeferToTraceExecute: Third
    < Exit DelegateDeferToTraceExecute
</pre> 

<h4 id="defer-condicional">Defer condicional</h4>

<pre>
Defer(
  procedure(
    if Datatabase.InTransaction then
    begin
      if Object.IsValid then
          Datatabase.Commit
      else
          Datatabase.RollBack;
    end;
  )
);
</pre> 

<h4 id="defer-como-destructor-para-o-record">Defer como destructor para o record</h4>

<pre>
type
  TValueType<T> = record
  private
    FAnyObject: TAnyObject;
    FDeferrer: IDeferrer;
    FValue: T;
  public
    constructor Create(Value: T);
  end;  
constructor TValueType<T>.Create(Value: T);
begin
  FValue := Value;
  FAnyObject := TAnyObject.Create
  FDeferrer  := Defer(FAnyObject.Free);
end;
</pre> 

<h2 id="vantagens">Vantagens</h2>

<p>Adiar a execução de procedures tem algumas vantagens:</p>

<ul>
<li><p>Garante que você não vai esquecer finalizar um recurso,
um erro bem comum quando é feito a manutenção do código e novas condições
são adicionadas, criando um novo fluxo.</p></li>

<li><p>O código de finalização fica junto ao de inicialização, que é
mais legível do que colocar no fim do método;</p></li>

<li><p>Dispensa a necessidade de blocos try/finally para garantir que um
recurso seja finalizado.</p></li>

<li><p>Mesmo que ocorra uma excessão, todos os métodos agendados no Defer
serão executados.</p></li>
</ul>

<h2 id="ressalvas">Ressalvas</h2>

<ul>
<li><p>O defer adiciona uma pequena sobrecarga, pois um objeto é criado e a sua finalização irá acumular a execução das procedures, código que seria executado de qualquer forma. Mas eu considero que se não se tratar de um código de alta performance, a utilização traz mais vantagens que desvantagens.</p></li>

<li><p>Evite usar defer dentro de loops, se for necessário alocar e desalocar recursos dentro de um loop, a desalocação deve ser deterministica. O uso excessivo pode aumentar muito o consumo de memória e causar lentidão.</p></li>

<li><p>Ao usar com métodos anônimos tenha em mente que o estado é capturado,
qualquer variável utilizada, terá o valor capturado no momento em que
o defer for declarado e não o valor alterado durante o fluxo da
procedure.</p></li>

<li><p>Esta padrão é baseado na function Defer em Golang e não tem relação
aos padrões &ldquo;Deferred/Promise&rdquo; e &ldquo;Deferred Choice&rdquo;.</p></li>
</ul>

<h2 id="repositório">Repositório</h2>

<ul>
<li><a href="https://github.com/cesarliws/foundation-4-delphi" target="_blank">Foundation 4 Delphi</a></li>
</ul>

<p>O projeto está hospedado no github, eu farei outro post apenas para falar do framework e do que estou preparando para ele. Muita coisa está pronta e em produção, então aguardem notícias em breve.</p>

      </p>
      <comments>
        <div id="disqus_thread"></div>
<script type="text/javascript">
(function() {
    if (window.location.hostname == "localhost")
        return;
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'cesarliws';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    var disqus_config = function () { 
        this.language = "en";
    };
})();
</script>
<noscript>
    Please enable JavaScript to view the 
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </comments>
    </article>
  </main>

<footer>
  <div class="footer_text">
      <div>
        <h3>Hi, <a href="">I'm Cesar</a></h3>
        <p>
          Software Architect at <a href="www.triersistemas.com.br">Trier Sistemas</a>, and
<br /> <a href="https://www.embarcadero.com/embarcadero-mvp-program">Embarcadero MVP</a>.
<br /> Regular speaker at software conferences. 
<br /> [desktop, cloud and mobile in mostly in <a href="https://www.embarcadero.com/products/delphi">Delphi</a> and <a href="https://golang.org/">Golang</a>]

        </p>
      </div>
  </div>

  
    <div class="footer_copyright">
      &copy; 2017 <a href="">Cesar Romero</a>
       - Made in Tubarão - SC, Brazil
    </div>
  
</footer>

    <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.0/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.2.14/js/lightgallery-all.min.js" charset="utf-8"></script>
    <script src="/js/weblog.js" charset="utf-8"></script>
    <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js" type="text/javascript"></script>]
<script src="http://agorbatchev.typepad.com/pub/sh/3_0_83/scripts/shBrushDelphi.js" type="text/javascript"></script>]
    
    
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-96993514-1', 'auto');
ga('send', 'pageview');
</script>

  </body>
</html>

